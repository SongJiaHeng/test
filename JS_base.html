<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        //显示字符串长度
        // var str = 'my name is Kingyo';
        // console.log(str.length);
        
        //拼接字符串  只要有字符串，拼接结果就是字符串
        // console.log('沙漠' + '骆驼');
        // console.log('Kingyo' + 18);
        // console.log('Kingyo' + true);
        // console.log('12' + 12);
        //变量不要写进字符串里面
        // var age = 18;
        // console.log('Kingyo' + age +'岁');
        
        // var age = prompt('请输入你的年龄');
        // var str = '您今年已经' + age + '岁了';
        // alert(str);

        //布尔型
        // var flag = true;
        // var flag1 = false;
        
        //undefined和数字相加返回NaN ,可以和字符串拼接
        //null和数字相加返回数字(null数字为空),可以和字符串拼接

        //prompt取过来的值是String类型的
        // var num = 10;
        // console.log(typeof num);
        // var age = prompt('请输入你的年龄');
        // console.log(age);
        // console.log(typeof age);
        
        // var num = 10;
        // var str = num.toString();
        // console.log(str);
        // console.log(typeof str);
        // console.log(num + '');//拼接字符串 隐式转换
        
        //转换为数值型 parseInt() 转换为整数 会去掉单位
        // parseFloat() 转换为小数 
        // var age = prompt('请输入您的年龄');
        // console.log(typeof parseInt(age));
        // console.log(Number('11.15'));
        
        //计算年龄
        // var year = prompt('请您输入您的出生年份');
        // alert('您今年已经' + (2020 - year) +'岁了')

        //简单加法器
        // var input1 = prompt('请输入第一个值');
        // var input2 = prompt('请输入第二个值');
        // var result = parseInt(input1) +parseInt(input2);
        // alert('计算结果为' + result);

        //作业一
        // var name = prompt('请输入您的姓名：');
        // var age = prompt('请输入您的年龄：');
        // var sex = prompt('请输入您的性别：');
        // alert('您的姓名是：' + name + '\n'
        //     +'您的年龄是：' + age + '\n'
        //     +'您的性别是：' + sex);

        // 前置递增运算符  ++p; 先自增,后返回值
        // 后置递增运算符  p++; 先返回原值,后自增
        // var age = 10;
        // console.log(age++ + 10); // 结果为20
        // console.log(age);        // age为11
        // var e = 10;
        // var f = e++ + ++e;  //e++为10 e为11 ++e为12 e为12
        // console.log(f);
        
        // ==会默认转换数据类型，把字符类型转换为数字类型
        // var res1 = 10 != 11;
        // console.log(res1);

        // 逻辑运算符 与&&(优先级高于或)    或||
        // 逻辑运算是短路运算  若前面能判断出结果，后面的就不会再运行
        // 在&&运算中 若第一个表达式的值为真,则返回表达式二;反之返回表达式一
        // 在||运算中 若第一个表达式的值为真,则返回表达式一;反之返回表达式二

        // else后面不跟条件表达式
        // var year = prompt('请输入要检测的年份：');
        // if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
        //     alert(year + '年是闰年');
        // } else {
        //     alert(year + '年是平年')
        // }

        // var score = prompt('请输入您的分数');
        // if (score >= 90) {
        //     alert('A');
        // } else if (score >= 80) {
        //     alert('B');
        // } else if (score >= 70) {
        //     alert('C');
        // } else if (score >= 60) {
        //     alert('D');
        // } else {
        //     alert('E');
        // }

        // 三元表达式  条件表达式 ? 表达式1 ： 表达式2
        // 如果条件表达式为真,则返回 表达式1的值，反之返回表达式2的值
        // console.log(10 > 5 ? '是的' : '不是的');

        // var time = prompt('请输入一个 0 ~ 59 之间的数字');
        // var result = time < 10 ? '0' + time : time;   //把返回值赋给result
        // alert(result);

        // switch 语句  表达式的值和case后面的value值相匹配,如果都没有匹配则执行default的语句
        // 匹配的时候是严格相等  用于固定值
        // 如果当前case没有break 那么不会退出switch 继续执行下一个case
        // switch (表达式) {
            // case value1:
            //     执行语句1;
            //     break; 
            // default:
            //     执行最后的语句;
        // }

        // var fruit = prompt('请输入水果');
        // switch (fruit) {
        //     case '苹果':
        //         alert('苹果的价格是 3.5/斤');
        //         break;
        //     case '梨':
        //         alert('梨的价格是 5/斤');
        //         break;
        //     default:
        //         alert('没有此水果');
        // }

        // 循环 重复执行
        // for 通常跟计数有关  操作表达式最后执行
            // for (初始化变量;条件表达式;操作表达式) {
                    // 循环体
            // }
        // 平均数
        // var sum = 0;
        // for (i = 1;i <= 100;i++) {
        //         sum += i;
        // }
        // console.log(sum/(i-1));
        
        //偶数 奇数之和
        // var even = 0;
        // var odd = 0;
        // for (i = 0; i <= 100; i++) {
        //     if (i % 2 == 0){
        //         even += i;
        //     } else {
        //         odd += i;
        //     }
        // }
        // console.log('1~100之间所有的偶数和是' + even);
        // console.log('1~100之间所有的奇数和是' + odd);

        // var num = prompt('请输入学生人数');
        // var sum = 0;
        // for (var i = 1; i <= num; i++) {
        //     var score = prompt('请输入第' + i +'个学生的成绩');
        //     sum += parseFloat(score);
        // }    
        // console.log(num + '个学生的平均分为：' + sum/num);

        // 一行打印五个星星   循环拼接字符串
        // var str = '';
        // for (var i = 1; i <= 5; i++) {
        //     str += '☆';
        // }
        // console.log(str);

        // 双重for循环
        // var num1 = prompt('请输入行数');
        // var num2 = prompt('请输入列数');
        // var str = '';
        // for (var i = 1; i <= num1; i++) {
        //     for (var j = 1; j <= num2; j++) {
        //         str += '☆';
        //     }
        //     str += '\n';
        // }
        // console.log(str);

        // 打印倒三角
        // var num = prompt('请输入数量');
        // var str = '';
        // for (var i = 1; i <= num; i++) {
        //     for (var j = i; j <= num; j++) {
        //         str += '☆';
        //     }
        //     str += '\n';
        // }
        // console.log(str);

        // 九九乘法表
        // var str = '';
        // for (var i = 1; i <= 9; i++) {
        //     for (var j = 1; j <= i; j++) {
        //         str += i + '×' + j + '=' + i * j + '\t';
        //     }
        //     str += '\n';
        // }
        // console.log(str);

        // while循环   用于判断的条件比较复杂的情况 
        // 条件表达式为true 执行循环体 否则退出循环
        // 操作表达式在循环体内，别忘了   
        // while (条件表达式) {
        //     // 循环体
        // }

        // var message = prompt('你爱我吗?');
        // while (message != '我爱你') {
        //     message = prompt('你爱我吗?');
        // }
        // alert('我也爱你啊！');

        // continue会跳过本次循环,跳到i++,继续执行下一次循环
        // break跳出整个循环

        // 登录界面
        // var i = 1;
        // do {
        //     var user = prompt('请输入用户名');
        //     var password = prompt('请输入密码');
        //     if (user == 'admin' && password == '123456') {
        //         i++;
        //         alert('登录成功!');
        //     }
        // } while (i == 1)

        // 存款取款
        // var num = 100;
        // var operation = prompt('请输入您要的操作：\n' +
        //                         ' 1.存钱 \n' +
        //                         ' 2.取钱 \n' +
        //                         ' 3.显示余额 \n' +
        //                         ' 4.退出 \n');
        // switch (operation) {
        //     case '1': 
        //         var save = prompt('请输入存钱金额');
        //         num += parseFloat(save);
        //         alert('现在还剩' + num + '元');
        //         break;
             
        //     case '2': 
        //         var draw = prompt('请输入取钱金额');
        //         num -= parseFloat(draw);
        //         alert('现在还剩' + num + '元');
        //         break;

        //     case '3': 
        //         alert('现在还剩' + num + '元');
        //         break;

        //     case '4': 
        //         alert('成功退出！');
        //         break;
        // }

        // 数组(Array):一组数据的几何存储在单个变量下
        // 创建方式 1. var arr = new Array();
        //         2. var 数组名 = [];       数据用逗号分隔
        // 数组中没有某元素的话会返回 undefined

        // 遍历 取数组元素
        // var arr = ['red', 'blue', 'red and blue'];
        // for (var i = 0; i < arr.length; i++) {
        //     console.log(arr[i]);
        // }

        // 求数组中的最大值
        // var arr = [1, 2, 5, 8, 6, 7, 14, 52, 33];
        // var max = 0;
        // for (var i = 0; i < arr.length; i++) {
        //     if (arr[i] >= max) {
        //         max = arr[i];
        //     }
        // }
        // console.log(max);
        
        //数组转换为分割字符串
        // var arr = ['red', 'blue', 'red and blue'];
        // var str = '';
        // var sep = '|';
        // for (var i = 0; i < arr.length; i++) {
        //     str += arr[i] + sep;
        // }
        // console.log(str);
        
        // 新增数组元素 length长度可修改
        // var arr = ['red', 'blue', 'red and blue'];
        // arr.length = 5;
        // console.log(arr);
        //             修改索引号 追加/替换数组元素
        // arr[3] = '111';
        // arr = '111'  不要直接给数组名赋值，否则数组元素全部消失

        // 数组中存1~10
        // var arr = [];
        // for (var i = 0; i < 10; i++) {
        //     arr[i] = i + 1;
        // }
        // console.log(arr);

        // 筛选数组
        // var arr = [1, 2, 5, 8, 6, 7, 14, 52, 33];
        // var arr2 = [];
        // var j = 0;
        // for (var i = 0; i < arr.length; i++) {
        //     if (arr[i] > 5) {
        //         arr2[j] = arr[i];
        //         j++;
        //     }
        //     if (arr[i] > 5) {
        //         arr2[arr2.length] = arr[i];    //利用数组长度自动扩容
        //     }
        // }
        // console.log(arr2);
        
        // 反转数组
        // var arr = [1, 2, 5, 8, 6, 7, 14, 52, 33];
        // var newArr = [];
        // for (var i = 0; i < arr.length; i++) {
        //     newArr[newArr.length] = arr[arr.length - i - 1];
        // }
        // console.log(newArr);

        // 冒泡排序  依次交换相邻两个数组元素
        // var arr = [1, 2, 5, 8, 6, 7, 14, 52, 33];
        // for (var i = 0; i < arr.length - 1; i++) { // 外层循环管趟数
        //     for (var j = 0; j < arr.length - i - 1;j++) { // 内层循环管 每一趟的交换次数
        //         if (arr[j] > arr[j + 1]) {
        //             var temp = arr[j];
        //             arr[j] = arr[j + 1];
        //             arr[j + 1] = temp;
        //         }
        //     }
        // }
        // console.log(arr);
        
        // 函数 封装了一段可以被重复执行调用的代码段
        // 声明函数、调用函数
        // function getSum() {
        //     var sum = 0;
        //     for (var i = 0; i <= 100; i++) {
        //         sum += i;
        //     }
        //     console.log(sum);
        // }
        // 形参和实参，声明时是形参，调用时是实参
        // 形参是用来接收实参的，相当于变量
        // 若实参 多于 形参，则取形参个数 ；反之 多于的形参都定义为undefined,返回NaN

        // 利用函数求和
        // function getSum(num1, num2) {
        //     var sum = 0;
        //     for (var i = num1; i <= num2; i++) {
        //         sum += i;
        //     }
        //     console.log(sum);
        // }
        // getSum(1, 10);

        // 函数的返回值       应该把函数的返回值返回给调用者
        // 只要函数遇到return 就把后面的结果返回给 函数的调用者
        // 相当于 函数名() = return后面的结果
        // 函数遇到return后就会终止函数，只能返回一个值，以最后的为准，不过可以返回数组
        // 若没有return  则返回undefined

        // function getArrMax(arr) {
        //     var max = arr[0];
        //     for (var i = 1; i < arr.length; i++) {
        //         if (arr[i] > max) {
        //             max = arr[i];
        //         }
        //     }
        //     return max;
        // }
        // var result = getArrMax([1, 2, 5, 8, 6, 7, 14, 52, 33]);
        // console.log(result);
        
        // arguments 里面存储了所有传递过来的实参，展示形式是伪数组  只有函数才有
        // 伪数组 有length属性、按照索引的方式进行存储、没有真正数组的一些方法
        // function fn() {
        //     for (var i = 0; i < arguments.length; i++) {
        //         console.log(arguments[i]);
        //     }
        // }
        // fn(1, 2, 3)

        // 任意个数的最大值
        // function getArrMax() {
        //     var max = arguments[0];
        //     for (var i = 1; i < arguments.length; i++) {
        //         if (arguments[i] > max) {
        //             max = arguments[i];
        //         }
        //     }
        //     return max;
        // }
        // var result = getArrMax(1, 2, 5, 8, 6, 7, 14, 52, 33);
        // console.log(result);

        // 函数 冒泡排序
        // function sort(arr) {
        //     for (var i = 0; i < arr.length -1; i++) {
        //         for (var j = 0; j < arr.length - i - 1; j++) {
        //             if (arr[j] > arr[j + 1]) {
        //                 var temp = arr[j];
        //                 arr[j] = arr[j + 1];
        //                 arr[j + 1] = temp;
        //             }
        //         }
        //     }
        //     return arr;
        // }
        // var arr1 = sort([1, 2, 5, 8, 6, 7, 14, 52, 33]);
        // console.log(arr1);
        
        // 函数判断闰年
        // 函数是可以相互调用的
        // function isRunYear(year) {
        //     var flag = false;
        //     if (year % 4 == 0 && year % 100 != 0 || year % 400 ==0) {
        //         flag = true;
        //     }
        //     return flag;
        // }
        // console.log(isRunYear(2020));
        
        // function backDay() {
        //     var year = prompt('请您输入当前年份');
        //     if (isRunYear(year) == true) {
        //         alert('当前年份是闰年，2月份有29天');
        //     } else {
        //         alert('当前年份是平年，2月份有28天');
        //     }
        // }
        // backDay();
        
        // 匿名函数  类似于声明变量
        // var fun = function() {};
        // fun 是变量名 不是函数名

        // 全局与局部作用域 局部作用域在函数内 作用域不同时同一个变量不会冲突
        // 函数内部 没有声明直接赋值的变量也属于全局变量
        // 函数的形参可以看做局部变量
        // 全局变量只有当浏览器关闭的时候才会销毁，比较占资源
        // 局部变量在程序运行完毕后就会销毁

        // 作用域链
        // 内部函数访问外部函数的变量，采取链式查找(就进原则)的方式来决定取哪个值

        // 预解析
        // JS解释器在执行代码的时候分两步：1.预解析 2.代码执行
        // JS解析器会把js里的所有的 var 以及 function提升到当前作用域的最前面
        // 预解析 分为 变量预解析(提升) 和 函数预解析（提升）
        //   变量预解析：把所有的变量声明语句提升到当前作用域最前，不进行赋值操作
        //   函数预解析：把所有的函数声明语句提升到当前作用域最前，不调用函数

        // var num = 10;
        // fun();
        // function fun() {
        //     console.log(num);
        //     var num = 20;
        // }
        // // 等同于
        // var num;
        // function fun() {
        //     var num;
        //     console.log(num);  // 到此只声明了num,未赋值，因此是undefined
        //     num = 20;
        // }
        // fun();    // 调用函数的时候，根据就近原则

        // var a = b = c = 9;
        // 相当于 var a = 9, b = 9, c = 9; b,c作为全局变量

        // 对象是一个具体的事物  比如周星驰
        // 创建对象  1.字面量   2.new Object()   3.构造函数
        // 对象内部属性或者方法采取键值对形式，中间用逗号隔开，方法冒号后跟的是一个匿名函数
        // var obj = {
        //     uname: 'Kingyo',
        //     age: 20,
        //     sex: '男',
        //     sayHi: function() {
        //         console.log('Hi~');
        //     }
        // }
        // 调用属性时 采取 对象名.属性名  or  对象名['属性名']
        // 调用方法时 对象名.方法名()   别忘了小括号  对象里的函数叫方法
        // console.log(obj.uname);
        // obj.sayHi();
        
        // 利用new Object()的方式创建对象，新增属性与方法时采取追加法
        // var obj = new Object();
        // obj.uname = 'Kingyo';
        // obj.sayHi = function() {
        //     console.log('影分身术！');
        // }

        // 构造函数  一次创建一个对象，里面很多属性和方法是相同的
        // 因此可以利用函数的方法，重复这些相同的代码  这些函数就叫构造函数
        // 构造函数内部封装的是对象，名字首字母大写
        // 构造函数泛指某一大类，是对象的公共部分
        // 利用构造函数创建对象的过程称为实例化
        
        // function 构造函数名() {
        //     this.属性 = 值;
        //     this.方法 = function() {}
        // }
        // new 构造函数名();   // 调用方法

        // function Star(uname, age, sex) {
        //     this.name = uname; // uname为形式参数,name为对象内的属性
        //     this.age = age;
        //     this.sex = sex;
        // }
        // var ldh = new Star('刘德华', 18, '男'); // 返回的是一个对象
        // console.log(typeof(ldh));
        
        // 构造函数不需要return就可以返回结果
        // 构造函数的属性和方法前面必须加this,指向当前的对象

        // new关键字执行过程
        // new构造函数先在内存中创建了个空对象,然后this指向刚才的对象
        // 执行构造函数的代码，给对象添加属性和方法，然后返回新对象(不需要return)

        // 遍历对象    对象中是无序的  使用 for in 遍历  一般写k/key
        // var obj = {
        //     name: 'Kingyo',
        //     age: 21,
        //     sex: '男'
        // }
        // for (var k in obj) {
        //     console.log(k);   // k 是变量     输出的 是属性名
        //     console.log(obj[k]);  // obj[k]   输出的 是属性值
        // }

        // var computer = {
        //     color: 'blue',
        //     weight: '3',
        //     watchMovie: function() {
        //         console.log('看电影');
        //     }
        // }

        // 内置对象    对象分为自定义对象、内置对象   浏览器对象(JS独有)
        // 查阅 MDN   1.方法的功能 2.参数的意义和类型 3.返回值的意义和类型 4.demo测试

        // 封装自己的对象
        // var myMath = {
        //     PI: 3.1415926535,
        //     max: function() {
        //         var max = arguments[0];
        //         for (var i = 1; i < arguments.length; i++) {
        //             if (max < arguments[i]){
        //                 max = arguments[i];
        //             }
        //         }
        //         return max;
        //     },
        //     min: function() {
        //         var min = arguments[0];
        //         for (var i = 1; i < arguments.length; i++) {
        //             if (min > arguments[i]){
        //                 min = arguments[i];
        //             }
        //         }
        //         return min;
        //     }
        // }
        // console.log(myMath.PI);
        // console.log(myMath.max(1, 5, 8, 7));
        // console.log(myMath.min(1, 5, 8, 7));

        // 猜数
        // function getRandom(min, max) {
        //     return Math.floor(Math.random() * (max - min + 1)) + min;
        // }
        // var random = getRandom(1, 10);
        // var input = prompt('现在随机生成了一个1~10的整数，来猜猜看吧~\n请输入要猜的数字');
        // var i = 1;
        // while (i < 10) {
        //     if (input > random) {
        //         input = prompt('你猜的数字偏大啦~\n请重新输入吧~');
        //         i++;
        //     } else if (input == random) {
        //         alert('恭喜你猜对啦！');
        //         break;
        //     } else {
        //         input = prompt('你猜的数字偏小啦~\n请重新输入吧~');
        //         i++;
        //     }
        // }

        // Date() 日期对象   是一个构造函数 必须使用new 来创建日期对象
        // 参数常用的写法  数字型  2019, 10, 01   或   字符串型 '2019-10-4 8:8:8'
        // var date1 = new Date(2019, 1, 1);
        // console.log(date1);
        // 格式化日期
        // var date = new Date();
        // // console.log(date.getFullYear());     // 年份
        // // console.log(date.getMonth() + 1);    // 月份  要加一
        // // console.log(date.getDate());         // 几号
        // // console.log(date.getDay());          // 周几   周日是0  周一是1
        // var year = date.getFullYear();
        // var month = date.getMonth() + 1;
        // var dates = date.getDate();
        // var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        // var day = date.getDay();         // 数字
        // console.log('今天是 ' + year + ' 年 ' + month + ' 月 ' + dates + ' 日  ' + arr[day]);
        
        // 格式化 时分秒
        // var date = new Date();
        // console.log(date.getHours());      // 时
        // console.log(date.getMinutes());    // 分
        // console.log(date.getSeconds());    // 秒

        // function getTime() {
        //     var time = new Date();
        //     var h = time.getHours();
        //     var m = time.getMinutes();
        //     var s = time.getSeconds();
        //     h = h < 10 ? '0' + h : h;
        //     m = m < 10 ? '0' + m : m;
        //     s = s < 10 ? '0' +  s: s;
        //     return h + ':' + m + ':' + s;
        // } 
        // console.log(getTime());
        
        // Date 的总毫秒数   距离1970.1.1过了多少毫秒  (时间戳)  永远不会重复
        // 1. valueOf()   getTime()     方法
        // 2. var date1 = +new Date();  常用
        // 3. Date.now() H5新增 获得总的毫秒数
        
        // 倒计时案例  用时间戳计算  然后转换为天、时、分、秒
        function countDown(time) {
            var nowTime = +new Date();
            var inputTime = +new Date(time);
            var times = inputTime - nowTime; 
            var days = parseInt(times / 1000 / 60 / 60 / 24);
            days = days < 10 ? '0' + days : days;
            var hours = parseInt(times / 1000 / 60 / 60 % 24);
            hours = hours < 10 ? '0' + hours : hours;
            var minutes = parseInt(times / 1000 / 60 % 60);
            minutes = minutes < 10 ? '0' + minutes : minutes;
            var seconds = parseInt(times/ 1000 % 60);
            seconds = seconds < 10 ? '0' + seconds : seconds;
            return days + '天' + hours + '时'+ minutes + '分' + seconds + '秒';
        }
        console.log('还剩下' + countDown('2020-4-20 18:00:00'));
        var date = new Date();
        console.log(date);
        
        // new Array() 创建数组
        // var arr1 = new Array();     // 空数组
        // var arr1 = new Array(2);    // 长度为2，元素都是空
        // var arr1 = new Array(2,3);  // 数组中有两个元素 2和3

        // 检测是否为数组
        // 1. instanceof  运算符  检测是否为数组
        // 2. Array.isArray()   方法   H5新增的方法  ie9以上版本才支持

        // 添加删除数组元素方法
        // 1. push() 在数组末尾添加一个或多个数组元素 push完毕后，返回结果是新数组长度
        // arr.push(1,2,'nice');
        // console.log(arr.push(1, 2, 'pink'));   // 返回数组长度
        // 2. unshift()  在数组首部添加
        // 3. pop()  删除数组最后一个元素，不加参数，返回值是删除的元素
        // 4. shift() 删除数组的第一个元素，不加参数，返回值是删除的元素

        // 筛选数组
        // var arr = [1500, 2000, 2500, 2100, 1900, 2400];
        // var newArr = [];
        // for (var i = 0; i < arr.length; i++) {
        //     if (arr[i] < 2000) {
        //         // newArr[newArr.length] = arr[i];
        //         newArr.push(arr[i]);
        //     }
        // }
        // console.log(newArr);

        // 数组排序 （冒泡排序）
        // arr.reverse();   // 翻转数组
        // arr.sort();      // 冒泡排序  有一些问题，会从最高位判断
        // // sort解决方案
        // arr.sort(function(a, b) {
        //     return a - b;   // 升序的顺序排列
        //     return b - a;   // 降序的顺序排列
        // })
        
        // 索引     
        // arr.indexOf('blue'); 从前往后找，只返回第一个符合条件的索引号，找不到返回 -1
        // arr.lastIndexOf();  从后往前找，返回第一个符合条件的索引号，找不到返回 -1
        // indexOf('要查找的元素', 开始查找的位置/索引号)

        // 数组去重
        // 用旧数组中的元素一个个去新数组(初始为空)里去查找，重复则不添加
        // function unique(arr) {
        //     var newArr = [];
        //     for (var i = 0; i < arr.length; i++) {
        //         if (newArr.indexOf(arr[i]) === -1) {
        //             newArr.push(arr[i]);
        //         }
        //     }
        //     return newArr;
        // }
        // var demo = unique(['c', 'a', 'z', 'a', 'x', 'a', 'x', 'y', 'm', 'e', 'c']);
        // console.log(demo);
        
        // 基本包装类型     把简单数据类型包装成了复杂数据类型 
        // var str = 'Kingyo';  // 该语句发生了如下变化
        // var temp = new String('Kingyo');  // 1. 把简单数据类型包装为复杂数据类型
        // str = temp;       // 2. 把临时变量的值 给 str
        // temp = null;      // 3. 销毁临时变量

        // 查找元素出现位置和次数
        // function find(str,f) {
        //     var location = [];
        //     var count = 0;
        //     var index = str.indexOf(f);
        //     for (i = 0; i < str.length; i++) {
        //         if (index !== -1) {
        //             location.push(index);
        //             count++;
        //             index = str.indexOf(f, index + 1);  // 每次查找到后，开始查找的位置+1
        //         }
        //     }
        //     return f + '出现的位置分别为：' + location + '\n出现的次数是' + count;
        // }
        // var str = 'ajdaksjdadlfhdsfneflwuedfwlscds';
        // console.log(find(str,'a'));
        // console.log(str.length);
        
        // 根据位置返回字符
        // 1. charAt(index)  索引号  返回字符
        // 2. charCodeAt(index)   返回ASCII值  目的：判断用户按下了哪个键
        // 3. str[index]  获取指定位置字符   H5新增

        // 对象['属性名'] 用来判断是否有该属性  返回布尔值

        // 判断字符串中出现次数最多的字符
        // var str = 'ajdaksjdadlfhdsfneflwuedfwlscds';
        // var o = {};
        // var max = 0;
        // var ch = '';
        // for (i = 0; i < str.length; i++) {
        //     var chars = str.charAt(i);
        //     if (o[chars]) {
        //         o[chars]++;
        //     } else {
        //         o[chars] = 1;
        //     }
        // }
        // for (var k in o) {
        //     if (max < o[k]) {
        //         max = o[k];
        //         ch = k;
        //     }
        // }
        // console.log('出现次数最多的字母是:' + ch + '\n它出现的次数为' + max);
        // console.log(o);
        
        // 字符串操作方法
        // 连接字符串 concat('字符串1', '字符串2'...)
        // 截取字符串 substr('截取的起始位置(包含该字符)', '截取几个字符');
        // var str1 = '彩彩修车秀哇秀哇';
        // console.log(str1.substr(2, 2));
        // 替换字符串 str.replace('被替换的字符', '替换零件');  只会替换第一个字符
        // 替换所有字符串
        // function replaceAll(str, f1, f2) {
        //     var index = str.indexOf(f1);
        //     for (i = 0; i < str.length; i++) {
        //         if (index !== -1) {
        //             str = str.replace(f1, f2);
        //         }
        //     }
        //     return str;
        // }
        // var str = 'abcoefoxyozzopp';
        // console.log(replaceAll(str, 'o', '*'));
        
        // 字符串转换为数组 split('分隔符')    
        // var str = 'red, pink, blue, color';
        // console.log(str.split(', '));
        
        // 简单数据类型：基本数据类型/值类型   null返回的是一个空的对象
        // 复杂数据类型：通过new创建的对象。存储时变量中存储到仅仅是地址。
        // 简单数据类型放到堆里面；复杂数据类型放到栈里面
        // 简单：在栈中开辟空间(里面直接是值)，变量名直接指向，存放的是值
        // 复杂：在栈中开辟空间(里面存的是指向堆里的地址),然后在堆中存放数据。

        // 简单  
        // 复杂  由于会先在栈中开辟空间存放地址，故形参和实参都会对对象有影响

    </script>
</head>
<body>
    
</body>
</html>